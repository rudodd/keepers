// Import library functionality
import React from 'react'
import Head from 'next/head';
import Router from 'next/router';

export default function Faq() {

  return (
    <div className="app-container faq">
      <Head>
        <title>Tummy Sleeper's Keepers</title>
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <h1>Tummy Sleeper's <span>Keepers</span><button onClick={() => Router.push('/')}>Home</button></h1>
      <h3>Frequently asked questions:</h3>
      <hr />
      <h4>What does that mean?</h4>
      <ul>
        <li><strong>ADP:</strong> - if you don't know this, you should not use this app</li>
        <li><strong>ECR:</strong> - Expert Consensus Ranking - player ranking from a consensus of fantasy football "experts" as provided by Fantasy Pros</li>
        <li><strong>Confidence:</strong> - The level of confidence the app has in predicting the keeper for a given team</li>
        <li><strong>Keeper score:</strong> - the score generated by the app used to determine a player's value as a keeper.  Given that we are working with variable values, like number of draft rounds (if we ever decide to add or remove rounds), this is not a predefined range like 0 - 100, nor is it linear.  Instead, it is a range of 0 to an infinite value as determined by the variables like number of rounds, etc...  A descent score is probably around 10, a good score is probably something over a 25 with anything approaching 100 being a really good score.  That said, a perfect keeper score in the current environment would be 1,700, so you can see that this is not a linear scoring system.  See the calculation explanation below for a more detailed explanation.</li>
      </ul>
      <hr />
      <h4>How do you calculate that?</h4>
      <ul>
        <li><strong>Rounds</strong> - Rounds cannot be calculated by just dividing the draft position by 8.  Instead we have to divide by eight, and then check if that number has a remainder and if it does, we add 1 round to the number.<br /><strong>Example: </strong>
          <ul>
            <li>27 / 8 = 3.375</li>
            <li>then we check modulo 1 (3.375 % 1 = 0.375)</li>
            <li>then since 0.375 &gt; 0 we add 3 + 1 = 4</li>
            <li>so draft position 27 wil be drafted in round 4</li>
          </ul></li>
        <li><strong>Valued at round</strong> - calculated by averaging the ADP and ECR and then determining the round at which that draft position would fall</li>
        <li><strong>Confidence</strong> - calculated by taking the top two players on a given team, by keeper score, and looking at the difference between them.  The larger the difference between their keeper scores, the greater the confidence in the pick prediction.</li>
        <li>
          <strong>Keeper score</strong><br /> To determine the value of a keeper there are three factors the algorythm considers... player's position (we'll call this positionValue), their expected value (we'll call this rankValue), and distance between expected draft position (we'll call this valueRound) and position they can be kept at (we'll call this keepRound). Below are the current positional values applied by the algorythm:
          <ul>
            <li>RB: 1.0</li>
            <li>WR: 0.8</li>
            <li>QB: 0.5</li>
            <li>TE: 0.5</li>
            <li>All others: 0.0</li>
          </ul>
          The formula looks something like this: 
          <pre>Number((((keepRound - valueRound) * positionValue) / rankValue) * 100).toFixed(2)</pre>
          So for the perfect keeper - meaning you are keeping the number one overall pick, who is a RB, in the 18th round - you would have:
          <pre>Number((((18 - 1) * 1.0) / 1) * 100).toFixed(2) = 1,700.00</pre>
          For a more realistic example, let's say you can keep a WR with ADP of 30 and ECR of 25 (4th round) in the 15th round, you would have:
          <pre>Number((((15 - 4) * 0.8) / 28) * 100).toFixed(2) = 31.42</pre>
        </li>
      </ul>
    </div>
  )
}
